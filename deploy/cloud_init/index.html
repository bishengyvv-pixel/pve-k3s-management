<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PVE è™šæ‹Ÿæœºç®¡ç† Agent èŠå¤©ç•Œé¢</title>
    <style>
        /* CSS æ ·å¼ */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f9;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .chat-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            height: 90vh;
        }

        .header {
            background-color: #3f51b5;
            color: white;
            padding: 15px 20px;
            font-size: 1.2em;
            font-weight: 600;
            text-align: center;
        }

        .messages {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            border-bottom: 1px solid #eee;
            scroll-behavior: smooth;
        }

        .message-box {
            margin-bottom: 15px;
            max-width: 85%;
            padding: 10px 15px;
            border-radius: 10px;
            line-height: 1.5;
        }

        .user-message {
            background-color: #e0f7fa;
            color: #00796b;
            margin-left: auto;
            border-bottom-right-radius: 2px;
        }

        .agent-message {
            background-color: #f0f4f7;
            color: #333;
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        /* ç¡®ä¿ Markdown æ¸²æŸ“çš„å…ƒç´ åœ¨ Agent æ¶ˆæ¯ä¸­æ­£ç¡®æ˜¾ç¤º */
        .agent-message pre {
            background-color: #e8ebf0;
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 0.9em;
        }
        .agent-message code {
            font-family: monospace;
        }
        .agent-message p {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .input-area {
            display: flex;
            padding: 15px 20px;
            border-top: 1px solid #eee;
        }

        .input-area input[type="text"] {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #ccc;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 1em;
            outline: none;
        }

        .input-area button {
            background-color: #3f51b5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
        }

        .input-area button:hover:not(:disabled) {
            background-color: #303f9f;
        }

        .input-area button:disabled {
            background-color: #9fa8da;
            cursor: not-allowed;
        }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨æ ·å¼ */
        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            margin-top: 5px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .status-thought {
            background-color: #fff3e0;
            color: #ff9800;
        }

        .status-tool {
            background-color: #e8f5e9;
            color: #4caf50;
        }

        .status-error {
            background-color: #ffebee;
            color: #f44336;
        }
    </style>
    <!-- å¼•å…¥ marked.js CDN ä»¥æ”¯æŒ Markdown æ¸²æŸ“ -->
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js"></script>
</head>
<body>

    <div class="chat-container">
        <div class="header">PVE Agent</div>
        
        <div class="messages" id="messages">
            <div class="message-box agent-message">
                ä½ å¥½ï¼æˆ‘æ˜¯ä¸€ä¸ª Proxmox VE (PVE) è™šæ‹Ÿæœºç®¡ç†ä¸“å®¶ã€‚è¯·è¾“å…¥ä½ çš„ä»»åŠ¡ï¼Œä¾‹å¦‚ï¼š`è¯·åœ¨ pve-1 èŠ‚ç‚¹ä¸Šåˆ›å»ºä¸€ä¸ª k3s æ§åˆ¶èŠ‚ç‚¹ï¼ŒIP åœ°å€ä¸º 192.168.10.50`
            </div>
        </div>

        <div class="input-area">
            <input type="text" id="userInput" placeholder="è¾“å…¥ä½ çš„æŒ‡ä»¤..." autofocus>
            <button id="sendButton" onclick="sendMessage()">å‘é€</button>
        </div>
    </div>

    <script>
        // JavaScript é€»è¾‘
        const API_URL = "http://192.168.116.100:9999/chat"; // ç¡®ä¿ä¸åç«¯é…ç½®ä¸€è‡´
        const messagesDiv = document.getElementById('messages');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        let isStreaming = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨æ¥æ”¶æµ

        /**
         * æ»šåŠ¨åˆ°åº•éƒ¨
         */
        function scrollToBottom() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        /**
         * æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
         * @param {string} content - æ¶ˆæ¯å†…å®¹
         */
        function addUserMessage(content) {
            const msgBox = document.createElement('div');
            msgBox.className = 'message-box user-message';
            msgBox.innerText = content;
            messagesDiv.appendChild(msgBox);
            scrollToBottom();
        }

        /**
         * åˆ›å»ºä¸€ä¸ª Agent æ¶ˆæ¯å®¹å™¨å¹¶è¿”å›å…¶å†…å®¹å…ƒç´ 
         * @returns {HTMLElement} - ç”¨äºå¡«å……å†…å®¹çš„å…ƒç´ 
         */
        function createAgentMessage() {
            const msgBox = document.createElement('div');
            msgBox.className = 'message-box agent-message';
            // åˆ›å»ºä¸€ä¸ªå†…éƒ¨ div æ¥å®¹çº³å†…å®¹ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥è½»æ¾æ›¿æ¢å®ƒè€Œä¸å½±å“å¾½ç« 
            const content = document.createElement('div');
            msgBox.appendChild(content);
            messagesDiv.appendChild(msgBox);
            scrollToBottom();
            return content;
        }

        /**
         * æ·»åŠ çŠ¶æ€å¾½ç« ï¼ˆå¦‚ï¼šæ€è€ƒä¸­, å·¥å…·è°ƒç”¨ï¼‰
         * @param {HTMLElement} parentElement - å¾½ç« æ·»åŠ åˆ°çš„çˆ¶å…ƒç´  (message-box)
         * @param {string} type - çŠ¶æ€ç±»å‹ (thought, tool, error)
         * @param {string} text - å¾½ç« æ–‡æœ¬
         */
        function addStatusBadge(parentElement, type, text) {
            const badge = document.createElement('span');
            badge.className = `status-badge status-${type}`;
            badge.innerText = text;
            parentElement.prepend(badge); // é¢„å…ˆæ·»åŠ åˆ°æ¶ˆæ¯æ¡†é¡¶éƒ¨
            scrollToBottom();
            return badge;
        }

        /**
         * å‘é€æ¶ˆæ¯çš„ä¸»å‡½æ•°
         */
        async function sendMessage() {
            if (isStreaming) {
                console.warn("Stream already in progress.");
                return;
            }

            const message = userInput.value.trim();
            if (!message) return;

            // 1. UI å‡†å¤‡
            addUserMessage(message);
            userInput.value = '';
            sendButton.disabled = true;
            isStreaming = true;
            
            // ä¸º Agent å“åº”åˆ›å»ºä¸€ä¸ªæ–°çš„å®¹å™¨ (currentContentElement æ˜¯å†…å®¹å¡«å……åŒºåŸŸ)
            // å¿…é¡»ä½¿ç”¨ .parentElement æ¥è·å–æœ€å¤–å±‚çš„ .message-box å®¹å™¨
            const currentContentElement = createAgentMessage();
            const agentResponseContainer = currentContentElement.parentElement;


            let thoughtBadge = null;
            let toolCallBadge = null;
            let finalAnswerReceived = false;

            try {
                // 2. å‘èµ· SSE è¯·æ±‚
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message, thread_id: Date.now() }) // åŠ¨æ€ç”Ÿæˆ thread_id
                });

                if (!response.ok) {
                    throw new Error(`HTTP é”™è¯¯: ${response.status}`);
                }
                
                // 3. è¯»å–æµ
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    // SSE è§£æ
                    let lines = buffer.split('\n');
                    buffer = lines.pop(); // ä¿ç•™æœ€åä¸€è¡Œä¸å®Œæ•´çš„è¡Œ

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const dataStr = line.substring(6).trim();
                                if (!dataStr) continue;

                                // æ£€æŸ¥å¹¶è·³è¿‡ç‰¹æ®Šçš„ç»“æŸæ ‡è®° "[DONE]"
                                // åŒæ—¶æ£€æŸ¥å¹¶è·³è¿‡é JSON æ ¼å¼çš„å¼€å§‹æ ‡è®°ï¼Œä¾‹å¦‚ "å¼€å§‹å¤„ç†..."
                                if (dataStr === '[DONE]' || dataStr.startsWith('å¼€å§‹å¤„ç†')) {
                                    continue;
                                }

                                const payload = JSON.parse(dataStr);
                                
                                switch (payload.type) {
                                    case 'thought':
                                        // æ˜¾ç¤ºæ€è€ƒè¿‡ç¨‹
                                        if (thoughtBadge) thoughtBadge.remove(); // ç§»é™¤æ—§å¾½ç« 
                                        if (toolCallBadge) toolCallBadge.remove(); // ç§»é™¤å·¥å…·å¾½ç« 
                                        
                                        thoughtBadge = addStatusBadge(agentResponseContainer, 'thought', 'ğŸ¤– æ€è€ƒä¸­...');
                                        
                                        // ä½¿ç”¨ marked.parse æ¸²æŸ“æ€è€ƒå†…å®¹
                                        currentContentElement.innerHTML = marked.parse(`**æ€è€ƒ:** ${payload.content}`);
                                        break;

                                    case 'tool_call':
                                        // æ˜¾ç¤ºå·¥å…·è°ƒç”¨
                                        if (thoughtBadge) thoughtBadge.remove();
                                        if (toolCallBadge) toolCallBadge.remove();

                                        toolCallBadge = addStatusBadge(agentResponseContainer, 'tool', `ğŸ› ï¸ è°ƒç”¨ ${payload.name}`);
                                        
                                        // æ ¼å¼åŒ–å·¥å…·è°ƒç”¨å†…å®¹ï¼Œä½¿ç”¨ Markdown æ¸²æŸ“ä»£ç å—
                                        const toolCallMarkdown = `**å·¥å…·è°ƒç”¨:** \`${payload.name}\`\n\n\`\`\`json\n${JSON.stringify(payload.args, null, 2)}\n\`\`\``;
                                        currentContentElement.innerHTML = marked.parse(toolCallMarkdown);
                                        break;

                                    case 'answer':
                                        // æœ€ç»ˆç­”æ¡ˆ
                                        if (thoughtBadge) thoughtBadge.remove();
                                        if (toolCallBadge) toolCallBadge.remove();
                                        
                                        // ä½¿ç”¨ marked.parse æ¸²æŸ“æœ€ç»ˆç­”æ¡ˆ
                                        currentContentElement.innerHTML = marked.parse(payload.content);
                                        finalAnswerReceived = true;
                                        break;
                                        
                                    case 'error':
                                        if (thoughtBadge) thoughtBadge.remove();
                                        if (toolCallBadge) toolCallBadge.remove();
                                        addStatusBadge(agentResponseContainer, 'error', 'âŒ é”™è¯¯');
                                        currentContentElement.innerText = `[é”™è¯¯]: ${payload.content}`;
                                        break;
                                        
                                    // å¿½ç•¥ event: start
                                    default:
                                        // å¿½ç•¥å…¶ä»–æœªçŸ¥ç±»å‹
                                        break;
                                }

                                scrollToBottom();
                            } catch (e) {
                                console.error("Error parsing data line:", line, e);
                                // IMPORTANT: ç§»é™¤å°†è§£æé”™è¯¯ä¿¡æ¯æ‰“å°åˆ°èŠå¤©ç•Œé¢çš„é€»è¾‘ï¼Œåªåœ¨æ§åˆ¶å°è®°å½•ã€‚
                                // currentContentElement.innerText = currentContentElement.innerText + `\n[è§£æé”™è¯¯]: ${e.message}`; 
                                // æ­¤å¤„ä¸å†åšä»»ä½• UI æ›´æ”¹ï¼Œé¿å…å¹²æ‰°æ­£å¸¸çš„èŠå¤©å†…å®¹ã€‚
                            }
                        }
                    }
                }

            } catch (error) {
                console.error("Stream failed:", error);
                if (!finalAnswerReceived) {
                    addStatusBadge(agentResponseContainer, 'error', 'âŒ è¿æ¥å¤±è´¥');
                    currentContentElement.innerHTML = `ä¸ Agent çš„è¿æ¥ä¸­æ–­æˆ–å‘ç”Ÿé”™è¯¯: ${error.message}`;
                }
            } finally {
                // 4. UI æ¢å¤
                isStreaming = false;
                sendButton.disabled = false;
                userInput.focus();
                // ç§»é™¤æ‰€æœ‰å‰©ä½™çš„çŠ¶æ€å¾½ç« 
                if (thoughtBadge) thoughtBadge.remove();
                if (toolCallBadge) toolCallBadge.remove();
            }
        }

        // ç»‘å®šå›è½¦é”®å‘é€
        userInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !isStreaming) {
                sendMessage();
            }
        });
    </script>
</body>
</html>